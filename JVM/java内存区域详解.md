# Java内存区域详解 #

针对HotSpot虚拟机   
## 一 概述 ##   
## 二 运行时数据区域 ##   
### 线程私有的: ###   
- 程序计数器
- 虚拟机栈
- 本地方法栈   

### 线程共享的: ###
- 堆
- 方法区
- 直接内存(非运行时数据区的一部分)   

2.1 程序计数器   

2.2 Java虚拟机栈   
Java内存可以粗糙的区分为Heap和Stack,其中栈就是现在说的虚拟机栈,或者说是虚拟机栈中的局部变量表部分.   
局部变量表主要存放了编译器可知的各种数据类型,对象引用.   
Java虚拟机栈会出现两种异常:StackOverFlowError和OutOfMemoryError.   
- StackOverFlowError: 若Java虚拟机栈的内存大小不允许动态扩展,那么当线程请求的栈深度超过了当前Java虚拟机栈的最大深度的时候,
就会抛出StackOverFlowError异常
- OutOfMemoryError: 若Java虚拟机栈的内存大小允许动态扩展,且当前请求栈时内存用完了,无法再动态扩展了,此时就抛出OutOfMemoryError异常

java虚拟机栈随着线程的创建而创建,随着线程的死亡而死亡.

2.3 本地方法栈   
虚拟机栈为虚拟机执行Java方法服务,而本地方法栈是为虚拟机使用到的Native方法服务.在HotSpot虚拟机中和Java虚拟机栈合二为一了.   

2.4 堆   
java虚拟机所管理的内存中最大的一块,Java堆是所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的即使存放对象实例,几乎所有的对象实例以及数组都在这里分配内存.   

java堆是GC管理的主要区域,因此也被称为GC堆(Garbage Collected Heap). 从垃圾回收的角度,现在的收集器都采用分代垃圾收集算法,,所以Java堆可以细分为Eden空间,From Survior, To Survivior空间等.eden区,s0区,s1区都属于新生代,tentired区属于老年代.大部分情况,对象都会首先在Eden区域分配,在一次新生代垃圾回收后,如果对象还存活,则会进入s0或者s1,并且对象的年龄还会加1(Eden区到Survivor区后对象的初始年龄变为1),当它的年龄增加到一定程度(默认是15岁),就会被晋升到老年代中.对象晋升到老年代的年龄阈值,可以通过参数`-XX:MaxTenuringThreshold`来设置.   

2.5 方法区   
方法去和Java堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.   
2.5.1 方法区和永久代的关系   
方法区和永久代的关系类似于Java中接口和类的关系.(JDK 1.8之后,方法区被彻底移除了,取而代之是元空间,元空间使用的是直接内存.
2.5.2 常用参数    
2.5.3 为什么要将永久代替换为元空间呢?   

2.6 运行时常量池   
JDK1.7及以后版本的JVM已将运行时常量池从方法区中移了出来,在Java堆中开辟了一块区域存放运行时常量池   
2.7 直接内存   
直接内存并不是虚拟机运行时数据区的一部分,也不是虚拟机规范中定义的内存区域,但是这部分内存也被频繁地使用.而且可能会导致OutOfMemoryError异常出现   

## 三 HotSpot虚拟机对象探秘 ##   
**3.1 对象的创建**   
**step1: 类加载检查  ** 
虚拟机遇到一条new指令时,首先将区检查这个指令的参数是否能在常量池中定位到这个类的符号引用,并且检查这个符号引用代表的类是否已被加载过,.解析和初始化过.如果没有,则必须执行相应的类加载过程.   

**step2: 分配内存  ** 
在类加载检查通过后,接下来虚拟机将为新生的对象分配内存.对象所需的内存大小在类加载完成后便可确定,为对象分配空间的任务等于把一块确定大小的内存从java堆中分出来.分配的方式又"指针碰撞"和"空闲列表"两种,选择哪种分配方式由Java堆是否规整决定,而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定.   
**内存分配的两种方式:**   

**内存分配并发问题:**   
虚拟机两种保证线程安全的方式:   

- CAS+失败重试: CAS时乐观锁的一种实现方式.   
- TLAB: 为每一个线程预先在Eden区分配一块内存,JVM在给线程中的对象分配内存时,首先在TLAB分配,当 对象大于TLAB中剩余内存或者TLAB的内存已耗尽,再采用上述的CAS进行内存分配   

**Step3: 初始化零值**   

**Step4: 设置对象头**   
例如对象是哪个类的实例,类的元素据信息,对象的哈希码,对象的GC分代年龄等.   

**Step5: 执行init方法**   

**3.2 对象的内存布局**  
再HotSpot虚拟机中,对象再内存中分为:对象头,实例数据,对齐填充.   
对象头包括两部分信息:存储对象自身的运行时数据(哈希码,GC分代年龄,锁状态等),另一部分是指针类型,即对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例.   

实例数据是对象真正存储的有效信息,也是在程序中所定义的各种类型的字段内容.   

对齐填充部分不是必然存在的,也没有什么特别的含义,仅仅起占位的作用.在HotSpot虚拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍.    

**3.3 对象的访问定位**   
  
